{
"lockfileVersion": 1
lock file in the versions of the full dependency tree
}

# Docker

Docker is a platform for developers and sysadmins to build, run, and share applications with containers
Use of containers to deploy application is called containerization.
A container is a running process, with some added encapsulation features applied to it in order to keep it isolated from the host and from other containers.
Each container interacts with its own private filesystem (Docker Image)
Docker Image - everything needed to run an application - the code or binary, runtimes, dependencies, and any other filesystem ocjects required

The kernel decides who will use these resources and for how long and when

Containers x Virtual Machines

A container runs natively on Linus and shares the kernel of the host machine with other containers. It runs a discrete process, taking no more memory than any other executable, making it lighweight.

Virtual Machina runs a full-blown guest operating system with virtual access to host resources through a hypervisor (virtual machine monitor, is a software that creats and runs virtual machines, allows one host computer to support multiple guert VMs by virtually sharing its resources, such as memory and processing; make it possible to use more of a system's available resources and provide greater IT mobity since the guest VMs are independent of the host hardware, can be easily moved between different servers)

creating the images that your containers will be based on. Remember, a Docker image captures the private filesystem that your containerized processes will run in; you need to create an image that contains just what your application needs to run.

Dockfile: how to assemble a private filesystem for a container and has some metadata describing how to run a container based on this image.
Docker builds images automatically by reading the instructions from a Dockerfile -- a text file that contains all commands, in order, needed to build a given image
A Docker image consists of read-only layers each of which represents a Dockerfile instruction. The layers are stacked and each one is a delta of the changes from the previous layer

FROM ubuntu:18.04
COPY . /app
RUN make /app
CMD python /app/app.py

FROM creates a layer from the ubuntu:18.04 Docker image.
COPY adds files from your Docker client’s current directory.
RUN builds your application with make.
CMD specifies what command to run within the container.

multi-stage builds:
before: keep the image size down
Each instruction in the Dockerfile adds a layer to the image, and you need to remember to clean up any artifacts you don’t need before moving on to the next layer.

When you run the build.sh script, it needs to build the first image, create a container from it to copy the artifact out, then build the second image.

after:

With multi-stage builds, you use multiple FROM statements in your Dockerfile. Each FROM instruction can use a different base, and each of them begins a new stage of the build. You can selectively copy artifacts from one stage to another, leaving behind everything you don’t want in the final image. To show how this works, let’s adapt the Dockerfile from the previous section to use multi-stage builds.

Volume:
Volumes are the preferred mechanism for persisting data generated by and used by Docker containers.
can manage volumes using Docker CLI commands or the Docker API
volumes are often a better choice than persisting data in a container’s writable layer, because a volume does not increase the size of the containers using it, and the volume’s contents exist outside the lifecycle of a given container

Manage application data :

When you use a bind mount, a file or directory on the host machine is mounted into a container.. The file or directory is referenced by its absolute path on the host machine. By contrast, when you use a volume, a new directory is created within Docker’s storage directory on the host machine, and Docker manages that directory’s contents.

If you start a container with a volume that does not yet exist, Docker creates the volume for you

Compose:

A service definition contains configuration that is applied to each container started for that service, much like passing command-line parameters to docker run

## Commands

docker --version

docker run hello-world

docker image ls

creates a writeable container layer over the specified image and then starts it using the specified command
docker run

Docker Compose
Tool for defining and running multicontainer Docker applicaitons
a YAML file to configure your application's services
create and start all the services from your configuration

docker-compose.yml
Compose file format (version 2 - 1.10.0+) - Docker Engine Release
docker-compose up -d mongo
docker-compose down
docker-compose exec mongo mongo
